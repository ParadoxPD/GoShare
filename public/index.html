<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>File Transfer</title>
    <style>
      body {
        font-family: sans-serif;
        padding: 2rem;
      }
      #progress {
        margin-top: 1rem;
      }
    </style>
  </head>
  <body>
    <h1>File Transfer</h1>
    <button onclick="receiveMode()">Receive</button>
    <button onclick="sendMode()">Send</button>

    <div id="app"></div>
    <div id="progress"></div>

    <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
    <script>
      const CHUNK_SIZE = 64 * 1024; // 64KB
      const encryptionKey = "examplekey123456";
      let ws = new WebSocket(`ws://${location.host}/ws`);
      let code;

      function receiveMode() {
        ws.send(JSON.stringify({ type: "register" }));
        let receivedChunks = [];

        ws.onmessage = async (event) => {
          const data = JSON.parse(event.data);
          console.log("Receiver got:", data);

          if (data.type === "code") {
            // Show QR and Join Code
            code = data.code;
            const app = document.getElementById("app");
            app.innerHTML = `<h2>Join Code: ${code}</h2><canvas id="qr"></canvas><p id="progress"></p>`;
            QRCode.toCanvas(document.getElementById("qr"), code);
          } else if (data.type === "chunk") {
            const chunk = await decryptBase64Chunk(data.content, encryptionKey);
            receivedChunks.push(chunk);
            document.getElementById("progress").innerText =
              `Received ${receivedChunks.length} chunks`;
          } else if (data.type === "done") {
            const blob = new Blob(receivedChunks);
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = data.name;
            a.click();
            receivedChunks = [];
            document.getElementById("progress").innerText +=
              "\nDownload complete.";
          }
        };
      }

      function sendMode() {
        const app = document.getElementById("app");
        app.innerHTML = `
        <input id="joinCode" placeholder="Enter Join Code"><br>
        <input type="file" id="fileInput"><br>
        <button onclick="connectAndUpload()">Connect & Upload</button>
      `;
      }

      const connectAndUpload = async () => {
        const inputCode = document.getElementById("joinCode").value;
        const file = document.getElementById("fileInput").files[0];
        if (!inputCode || !file) return;

        ws.send(JSON.stringify({ type: "connect", code: inputCode }));

        const onConnected = async (event) => {
          const data = JSON.parse(event.data);
          console.log("Sender got:", data);

          if (data.type === "connected") {
            ws.removeEventListener("message", onConnected); // Avoid duplicate sends
            await sendFileInChunks(file, inputCode);
          }
        };

        ws.addEventListener("message", onConnected);
      };

      async function sendFileInChunks(file, code) {
        const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
        const progress = document.getElementById("progress");
        console.log(file);

        for (let i = 0; i < totalChunks; i++) {
          const chunk = file.slice(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);
          const buffer = await chunk.arrayBuffer();
          const encrypted = await encryptBuffer(buffer, encryptionKey);

          ws.send(
            JSON.stringify({
              type: "chunk",
              code,
              index: i,
              name: file.name,
              content: encrypted,
            }),
          );

          progress.innerText = `Sent ${i + 1}/${totalChunks} chunks`;
        }

        ws.send(JSON.stringify({ type: "done", code, name: file.name }));
        progress.innerText += `\nUpload complete.`;
      }

      async function encryptBuffer(buffer, keyStr) {
        const key = await window.crypto.subtle.importKey(
          "raw",
          new TextEncoder().encode(keyStr),
          "AES-CBC",
          false,
          ["encrypt"],
        );
        const iv = window.crypto.getRandomValues(new Uint8Array(16));
        const encrypted = await window.crypto.subtle.encrypt(
          { name: "AES-CBC", iv: iv },
          key,
          buffer,
        );
        const combined = new Uint8Array(iv.byteLength + encrypted.byteLength);
        combined.set(iv, 0);
        combined.set(new Uint8Array(encrypted), iv.byteLength);
        return btoa(String.fromCharCode(...combined));
      }

      async function decryptBase64Chunk(base64, keyStr) {
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        const iv = bytes.slice(0, 16);
        const data = bytes.slice(16);

        const key = await window.crypto.subtle.importKey(
          "raw",
          new TextEncoder().encode(keyStr),
          "AES-CBC",
          false,
          ["decrypt"],
        );
        const decrypted = await window.crypto.subtle.decrypt(
          { name: "AES-CBC", iv: iv },
          key,
          data,
        );

        return new Uint8Array(decrypted);
      }
    </script>
  </body>
</html>
